# 결합(복합) 인덱스

데이터베이스의 용량이 점점 커지면서 단일 인덱스만으로 해결하기 어려운 상황이 되었다. 결합 인덱스는 이러한 대용량 데이터베이스에서 성능을 향상시킨다.
> 무조건 결합 인덱스가 좋다는 말은 아니다 대부분의 경우에는 결합 인덱스가 성능상 좋다는 말

<br>
처리 범위에 따라 SQL 성능은 달라진다. SQL 성능은 다음

* 처리 범위의 양
* 랜덤 액세스의 양
* 정렬의 양

3 가지 항목에 좌우된다.

---
## 1. 처리 범위의 양

### 1. 인덱스

```SQL
SELECT 이름, 이메일
FROM 사용자
WHERE 등록일자 = '20220804'
AND 이름 = '포비'
```

예로 든, SQL문에서 만들 수 있는 인덱스 종류를 살펴보자.

1. 등록일자 인덱스

처리 범위는 등록일자 컬럼에 의해서만 감소하게 되고, 이름에 의해서는 처리 범위가 감소하지 않는다.
따라서, 등록일자 컬럼 값이 `20220804`인 데이터를 모두 액세스 한 후, 이름이 `포비`인 데이터만 결과로 나타나게 된다.

2. 이름 인덱스

등록일자 인덱스처럼 이름 인덱스 컬럼에 의해서만 처리 범위가 감소하게 된다.

3. 등록일자 인덱스 + 이름 인덱스

처리 범위는 등록일자 컬럼 값이 `20220804`인 데이터를 액세스 한 후, 감소된 처리 범위에서 이름 컬럼 값이 `포비`인 데이터를 엑세한다. 앞의 등록일자 인덱스나 이름 인덱스 처럼 단일 인덱스보다 처리 범위가 더 감소하므로 SQL 성능 향상을 기대할 수 있다.

4. 이름 인덱스 + 등록일자 인덱스

3번째 인덱스와 같은 원리로 작동한다.

✔︎ 단일 인덱스보다는 결합 인덱스가 SQL 성능에 유리하다는 것을 느꼈을 것이다.

---
### 2. 인덱스 컬럼 구성 순서

```SQL
SELECT 이름, 이메일
FROM 사용자
WHERE 등록일자 = '20220804'  -- where절의 연산자
AND 이름 = '포비'
```

* where 절의 연산자 종류

1. 점 조건

`in`이나 `=` 연산자를 이용한 조건을 의미하며 해당 연산자는 하나의 점만을 의미

2. 선분 조건

`like`, `between`, `<`, `>` 등과 같이 점 조건을 제외한 연산자를 의미, 하나의 점이 아닌 길게 이저지는 범위를 나타냄

두 조건을 가지고 위 복합 인덱스의 조합을 나타내보면,

1. 점 조건 + 점 조건: `두 조건에 의해 처리 범위 감소`
2. 점 조건 + 선분 조건: `두 조건에 의해 처리 범위 감소`
3. 선분 조건 + 선분 조건: `앞의 선분 조건에 의해 처리 범위 감소`
4. 선분 조건 + 점 조건: `앞의 선분 조건에 의해 처리 범위 감소`

주의할 점은 앞에 조건이 선분 조건일 경우 뒤에오는 조건은 처리하지 않는다.

```SQL
/**
사용자 테이블에 70건의 데이터가 있고, 그 중 이름, 성이 밑의 조건을 만족한다고 가정

이름 - 포비: 10명, 그외: 60명
성   - 남자: 30명, 여자: 40명
**/

SELECT 이름, 이메일
FROM 사용자
WHERE 성 = '남'
AND 이름 = '포비';

SELECT 이름, 이메일
FROM 사용자
WHERE 이름 = '포비'
AND 성 = '남';
```

두 SQL문 사이에는 어떤 차이가 있을까?


```TEXT
1. 성 = '남' -> 이름 = '포비'

: 70건 조회 후 30건으로 추림 -> 30건 조회 후 추림

2. 이름 = '포비' -> 성 = '남'

: 70건 조회 후 10건으로 추림 -> 10건 조회 후 추림
```

먼저 오는 조건에서 최대한 데이터를 필터해야 뒤에 오는 조건들이 조회하는 데이터의 양이 줄어들고 이는 성능 향상으로 나타난다.

---
## 2. 랜덤 액세스의 양

랜덤 액세스는 데이터를 저장하는 블록을 한번에 여러 개 액세스하는 것이 아니라 한 번에 하나의 블록만을 액세스하는 싱글 블록 I/O 방식이다. 랜덤 액세스는 `인덱스를 액세스하여 확인한 ROWID를 이용하여 테이블을 액세스 하는 경우` 발생하게 된다.

싱글 블록 I/O 방식과 반대인 멀티 블록 I/O 방식을 사용하는 것은 테이블 풀 스캔(Table Full Scan)의 경우가 있다.

* 랜덤 액세스의 종류

1. 확인 랜덤 액세스

```SQL
SELECT 이름, 이메일
FROM 사용자
WHERE 등록일자 = '20220804' -- 등록일자 컬럼만 인덱스인 경우
AND 이름 = '포비'
```

SQL이 실행되면 등록일자 인덱스로 처리 범위가 좁혀지지만, 이름은 인덱스로 설정되어 있지 않았다. 결국, 등록일자 조건을 만족하는 모든 데이터에 대해 테이블을 액세스하여 이름 조건을 부합하는 값을 찾게 된다.

`WHERE 조건의 칼럼이 인덱스에 존재하지 않아 테이블 랜덤 액세스를 발생시키는 것을 확인 랜덤 액세스`라고 한다. 

확인 랜덤 액세스는 랜덤 액세스의 횟수보다 최종 결과가 동일하거나 더 적게 추출된다는 특직이 있다. 이는 확인 랜덤 액세스는 랜덤 액세스가 발생한 후 버려지는 데이터가 존재하기 때문이다. 인덱스 중에 확인 랜덤 액세스의 제거는 성능에 있어 매우 중요한 역할을 수행하게 된다.

2. 추출 랜덤 액세스

```SQL
SELECT 이메일  -- 등록일자, 이름 컬럼이 인덱스로 있지만 SELECT에 인덱스 컬럼이 없음 
FROM 사용자
WHERE 등록일자 = '20220804'
AND 이름 = '포비'
```

`SELECT 절의 컬럼을 결과로 추출하기 위해서는 실행 순서에 따라 인덱스 액세스 이후 테이블을 액세스 할 것이다. 이와 같은 현상이 추출 랜덤 액세스이다.`

추출 랜덤 액세스는 랜덤 액세스의 횟수와 추출되는 데이터의 양이 동일하다는 특징이 있다. SELECT 절의 컬럼들은 추출되는 데이터를 감소시키거나 증가시키지 못한다.

3. 정렬 랜덤 액세스

```SQL
SELECT 이메일
FROM 사용자
WHERE 등록일자 = '20220804'
AND 이름 = '포비'
ORDER BY 이메일 DESC -- 등록일자, 이름 컬럼이 인덱스로 있지만 ORDER BY에 인덱스 컬럼이 없음 
```

`ORDER BY 절 등에 사용된 컬럼이 인덱스에 존재하지 않아 테이블을 액세스하여 정렬을 수행하기 위해 데이터를 액세스할 것이다. 이와 같은 현상이 정렬 랜덤 액세스이다.`

정렬 랜덤 액세스 또한 랜덤 액세스의 횟수와 추출되는 데이터의 건수가 동일하게 된다.

<br>
정리하면 랜덤 액세스 중 확인 랜덤 액세스가 가장 많은 부하를 발생시키며 최우선적으로 확인 랜덤 액세스를 제거하기 위해 노력해야 한다. 추출 랜덤 액세스, 정렬 랜덤 액세스 제가하면 성능 향상에 도움이 된다.

<br>
해당 내용에 대한 것은 링크로 대신하겠다.

[추출 랜덤 액세스와 정렬 랜덤 액세스](http://www.gurubee.net/lecture/2235)

---
## 3. 정렬의 양

데이터베이스에서 데이터를 저장하는 장소는 테이블과 인덱스다.

* 테이블

데이터가 INSERT 되는 순서에 의해 저장되므로 어떤 칼럼에 의해 정렬된 데이터가 저장되지 않음

* 인덱스

인덱스를 구성하는 컬럼에 의해 정렬된 데이터가 저장된다. 인덱스의 첫 번째 컬럼에 의해 정렬되며 첫 번째 컬럼의 값이동일한 데이터에 대해서는 인덱스의 두 번째 컬럼에 의해 정렬된다.

```SQL
SELECT 이메일
FROM 사용자
WHERE 등록일자 = '20220804'
ORDER BY 이름
```

다음과 같은 SQL문에서 `ORDER BY 이름` 대신 `등록일자 + 이름` 컬럼으로 인덱스를 생성한다면 자동으로 정렬된 데이터가 추출 될 것이다.

`정렬을 제거하는게 정답은 아니다. 정렬을 제거하고 인덱스 효율을 떨어트릴지, 인덱스 효율을 높이고 정렬 부담을 가질지`, 각각의 상황에 맞게 선택하면 된다.

---
## 3. 정리

* 결합 인덱스를 이용하면 SQL 성능 향상에 도움이 됨

* 결합 인덱스가 적용되려면 순서가 중요
  - 등록일자, 이름으로 인덱스를 형성했다면 WHERE 조건을 등록일자부터 시작해야함
  - 조건절이 이름부터 시작하면 결합 인덱스가 적용되지 않음
  - 등록일자, 이름으로 인덱스를 형성했다면 WHERE 조건에 등록일자만 넣어도 결합 인덱스가 작용함

* 결합 인덱스를 구성하는 컬럼의 순서에 따라 성능 향상 효과가 있음
  - 1순위 : 컬럼이 사용한 연산자에 의한 인덱스 컬럼 선정
  - 2순위 : 랜덤 액세스를 고려한 인덱스 컬럼 선정
  - 3순위 : 정렬 제거를 위한 인덱스 컬럼 선정
  - 4순위 : 단일 컬럼의 분포도를 고려한 인덱스 컬럼 선정

---
## 참고

1.[결합 인덱스를 선정하는 우선순위](http://www.gurubee.net/lecture/2229)

2.[[인덱스] Composite INDEX(결합 인덱스)](https://jhkang-tech.tistory.com/210)

3.[정렬 제거를 위한 인덱스 컬럼 선정방법](http://www.gurubee.net/lecture/2236)